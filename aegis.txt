x 2022-12-19 complete `safe` tests. pri:A +safe @â–¶ï¸
x 2022-12-19 `./safe/test-admin-api-upsert-secret.sh` pri:A +safe @â–¶ï¸
x 2022-12-19 `./safe/test-notary-api-bootstrap.sh` pri:A +safe @â–¶ï¸
x 2022-12-19 `./safe/test-notary-api-workload.sh` pri:A +safe @â–¶ï¸
x 2022-12-19 `./safe/test-probe-api-healthz.sh` pri:A +safe @â–¶ï¸
x 2022-12-19 `./safe/test-probe-api-readyz.sh` pri:A +safe @â–¶ï¸
x 2022-12-19 `./safe/test-workload-api-fetch-secrets.sh` pri:A +safe @â–¶ï¸
x 2022-12-22 Implement `notary` API. pri:A +notary
x 2022-12-21 Implement `sidecar` API. pri:A +sidecar @â–¶ï¸
x 2022-12-19 `./safe/test-notary-api-readyz--after-bootstrap.sh` pri:A +safe
(C) Finalize `README.md`.
(D) Process `TODO:` items in the projects. +aegis 
(B) Finalize diagrams. +aegis 
(C) create a broad-brushstrokes roadmap.
(D) the website needs some content +aegis 
(E) what about mTLS? Maybe offload it to a mesh and keep it out of scope and/or conditionally enable with a configuration flag. +aegis 
(E) there is almost no logging in fail cases, incrase logging +aegis 
(E) right now everything is in memory; maybe provide other backing stores +aegis
(B) note that the initial prototype stores things â€œin memoryâ€ without encryption; it might be nice to introduce `sops` next when things stabilize +aegis 
(C) Add documentation to all publicly exported functions everywhere +aegis 
(C) Code cleanup everywhere +aegis
(B) use `sops` and `age` in some way, shape or form +aegis +safe @mvp 
(E) ability to rotate notaryId and safeId. +aegis 
(D) idea: integration with `SPIRE`. If there is a SPIRE server that `aegis` can piggyback on, then let it manage the registration instead of all these token and secret exchange.
(C) main goal is to keep things simple, usable, and cloud-native. I will most certainly assume some form of Kubernetes exists. +aegis 
(C) main goal: be pragrmatic +aegis â€” find the right balance between convenience and security by default, and let people to opt in for more secure updates if they want/need to. â€” the in memory store is a very good example: if people want, they can opt in for sops, but keeping thing in memory is secure enough in itself, the inconvenience here will be losing secrets when safe goes down; some can tolerate it, and some might need to persist the secrets in an encrypted way.
(D) exchange workload secrets and notary token regularly. +aegis 
(C) audit logging on api actions +aegis 
(C) none of the deployments have any limits; set some reasonable limits +aegis 
(C) Create a service account instead of using the default one +aegis
(E) sign the docker images and other artifacts that you distribute +aegis 
x 2022-12-23 record a demo video pri:A +aegis @â–¶ï¸
x 2022-12-23 tx renewal b4 29th pri:A @ðŸš¨
(B) convert minikube kubectl to kubectl in the deploy makefiles; maybe add a deploy-minikube as an alternative option +aegis 
(B) add make all; make install; make clean -- those are typical things people expect in makefiles +aegis 
(B) ensure that all `make` commands are working as expected +aegis 
(B) create a top-level makefile that builds and deploys all the child projects +aegis
environment variable check before launching containers +aegis 
(B) enable debug-level logging +aegis 
(B) add list of technologies used in README, and also add licenses of those to the things that you bundle +aegis 
(C) documentation: notary should be up and running first +safe â€” plus, it wouild be nice if safe for example can check the existence of notary
(B) in this current implementation, sidecars are constantly polling safe even though they don't have any secrets registered; they should back off after a while exponentially +sidecar 
(A) make notary deployable inside a cluster too. +aegis @mvp 
x 2022-12-23 a mini operations manual on README.md pri:A due:2022-12-24 +aegis @â–¶ï¸
(E) you need a CONTRIBUTING.md +aegis 
(B) A mini powerpoint presentation would be useful too. +aegis 
(B) A second app that talks to Aegis over mTLS and can be used to unlock Safe if Safe gets evicted and restarted for whatever reason. This app will require to store the admin token in memory (to trigger the restore operation via the Safe APIs). It can be deployed in a HA setup so that if one of them crashes, it can resync with others. I would like to call them â€œOraclesâ€ and keep it as a group of three.
(B) implement secure component-to-component connectivity using either TLS or mTLS. â€”aegis-keygen can generate certs if needed +aegis 
(A) make `make install` work for users with no write access to dockerhub. +aegis @â–¶ï¸ 
(A) establish a secure way to deliver the admin token +aegis -- Securing the admin key you will need a private key and a public key; you will have to keep your private key â€œprivateâ€safe:PUT /v1/crypto/key { publicKey: key } will register your public key.GET /v1/admin/key => will return the admin key encrypted with your public key.you can use aegis-keygen command line utility to generate a key pair.you can again use aegis-keygen command line utility to decrypt your admin tokenif either safe or notary crashes and restarts (after a successful bootstrap),you'll have to provide your private key to safe to recover from last knownstate. your private key is never logged or stored on disk, and it will bewiped out from memory as soon as there is no more need for it.Key Rotation: to be done in the future; right now admin token, notary token, and workload tokens are everlasting once they are dispatched.
(B) add license of nicolaka/netshoot to sentinel, since it is an almost item-by-item fork.
(C) update the README files of the child projects too +aegis
(E) multi-cluster federation? +aegis â€” we can expose Safe (securely) to other clusters (only) for an initial stab at the solution. but do we really need it. â€” the pods will likely want their secrets closer to them.
(C) create channels to provide feedback (maybe a discord group too; or maybe link z2h discord instaed +aegis )
(C) maybe create helm templates to customize all these yaml files. +aegis 
(C) automatic sidecar injection? +aegis 
(A) replace aegis-workload-key with aegis-workload-id everywhere for consistency +aegis
(E) we need an unregister flow for the deleted workloads too. -- or do we? not sure +aegis -- since the workload can revive, it might still be entitled to the same secrets.