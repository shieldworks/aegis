x 2022-12-19 complete `safe` tests. pri:A +safe @‚ñ∂Ô∏è
x 2022-12-19 `./safe/test-admin-api-upsert-secret.sh` pri:A +safe @‚ñ∂Ô∏è
x 2022-12-19 `./safe/test-notary-api-bootstrap.sh` pri:A +safe @‚ñ∂Ô∏è
x 2022-12-19 `./safe/test-notary-api-workload.sh` pri:A +safe @‚ñ∂Ô∏è
x 2022-12-19 `./safe/test-probe-api-healthz.sh` pri:A +safe @‚ñ∂Ô∏è
x 2022-12-19 `./safe/test-probe-api-readyz.sh` pri:A +safe @‚ñ∂Ô∏è
x 2022-12-19 `./safe/test-workload-api-fetch-secrets.sh` pri:A +safe @‚ñ∂Ô∏è
x 2022-12-22 Implement `notary` API. pri:A +notary
x 2022-12-21 Implement `sidecar` API. pri:A +sidecar @‚ñ∂Ô∏è
x 2022-12-19 `./safe/test-notary-api-readyz--after-bootstrap.sh` pri:A +safe
(C) Finalize `README.md`.
(D) Process `TODO:` items in the projects. +aegis 
x 2022-12-24 Finalize diagrams. pri:B +aegis
(C) create a broad-brushstrokes roadmap.
(D) the website needs some content +aegis 
(E) what about mTLS? Maybe offload it to a mesh and keep it out of scope and/or conditionally enable with a configuration flag. +aegis 
(E) there is almost no logging in fail cases, incrase logging +aegis 
(E) right now everything is in memory; maybe provide other backing stores +aegis
(B) note that the initial prototype stores things ‚Äúin memory‚Äù without encryption; it might be nice to introduce `sops` next when things stabilize +aegis 
(C) Add documentation to all publicly exported functions everywhere +aegis 
(C) Code cleanup everywhere +aegis
(B) use `sops` and `age` in some way, shape or form +aegis +safe @mvp 
(E) ability to rotate notaryId and safeId. +aegis 
(D) idea: integration with `SPIRE`. If there is a SPIRE server that `aegis` can piggyback on, then let it manage the registration instead of all these token and secret exchange.
(C) main goal is to keep things simple, usable, and cloud-native. I will most certainly assume some form of Kubernetes exists. +aegis 
(C) main goal: be pragrmatic +aegis ‚Äî find the right balance between convenience and security by default, and let people to opt in for more secure updates if they want/need to. ‚Äî the in memory store is a very good example: if people want, they can opt in for sops, but keeping thing in memory is secure enough in itself, the inconvenience here will be losing secrets when safe goes down; some can tolerate it, and some might need to persist the secrets in an encrypted way.
(D) exchange workload secrets and notary token regularly. +aegis 
(C) audit logging on api actions +aegis 
(C) none of the deployments have any limits; set some reasonable limits +aegis 
(C) Create a service account instead of using the default one +aegis
(E) sign the docker images and other artifacts that you distribute +aegis 
x 2022-12-23 record a demo video pri:A +aegis @‚ñ∂Ô∏è
x 2022-12-23 tx renewal b4 29th pri:A @üö®
(B) convert minikube kubectl to kubectl in the deploy makefiles; maybe add a deploy-minikube as an alternative option +aegis 
(B) add make all; make install; make clean -- those are typical things people expect in makefiles +aegis 
(B) ensure that all `make` commands are working as expected +aegis 
(B) create a top-level makefile that builds and deploys all the child projects +aegis
(B) environment variable check before launching containers +aegis 
(B) enable debug-level logging +aegis 
(B) add list of technologies used in README, and also add licenses of those to the things that you bundle +aegis 
(C) documentation: notary should be up and running first +safe ‚Äî plus, it wouild be nice if safe for example can check the existence of notary
(B) in this current implementation, sidecars are constantly polling safe even though they don't have any secrets registered; they should back off after a while exponentially +sidecar 
(A) make notary deployable inside a cluster too. +aegis @mvp 
x 2022-12-23 a mini operations manual on README.md pri:A due:2022-12-24 +aegis @‚ñ∂Ô∏è
(E) you need a CONTRIBUTING.md +aegis 
(B) A mini powerpoint presentation would be useful too. +aegis 
(B) A second app that talks to Aegis over mTLS and can be used to unlock Safe if Safe gets evicted and restarted for whatever reason. This app will require to store the admin token in memory (to trigger the restore operation via the Safe APIs). It can be deployed in a HA setup so that if one of them crashes, it can resync with others. I would like to call them ‚ÄúOracles‚Äù and keep it as a group of three.
(B) implement secure component-to-component connectivity using either TLS or mTLS. ‚Äîaegis-keygen can generate certs if needed +aegis 
x 2022-12-24 make `make install` work for users with no write access to dockerhub. pri:A +aegis @‚ñ∂Ô∏è
x 2022-12-24 establish a secure way to deliver the admin token  -- Securing the admin key you will need a private key and a public key; you will have to keep your private key ‚Äúprivate‚Äùsafe:PUT /v1/crypto/key { publicKey: key } will register your public key.GET /v1/admin/key => will return the admin key encrypted with your public key.you can use aegis-keygen command line utility to generate a key pair.you can again use aegis-keygen command line utility to decrypt your admin tokenif either safe or notary crashes and restarts (after a successful bootstrap),you'll have to provide your private key to safe to recover from last knownstate. your private key is never logged or stored on disk, and it will bewiped out from memory as soon as there is no more need for it.Key Rotation: to be done in the future; right now admin token, notary token, and workload tokens are everlasting once they are dispatched.    ‚Äî  1Password model: The encryption key is generated when you create the account. The only feasible way for it to be compromised is if the user leaks/shares it. Users don‚Äôt pick the key, nor is it derived from the account password. ‚Äî In our case `Save` can be used to return a private key, public key pair to the user; it will return the same pair only once; admin will store the keypair; and they will use the public key to retrieve an encrypted admin  token. The keygen endpoint will be locked after 10 consecutive uses. pri:B +aegis @üö® @mvp
(B) add license of nicolaka/netshoot to sentinel, since it is an almost item-by-item fork.
(C) update the README files of the child projects too +aegis
(E) multi-cluster federation? +aegis ‚Äî we can expose Safe (securely) to other clusters (only) for an initial stab at the solution. but do we really need it. ‚Äî the pods will likely want their secrets closer to them.
(C) create channels to provide feedback (maybe a discord group too; or maybe link z2h discord instaed +aegis )
(C) maybe create helm templates to customize all these yaml files. +aegis 
(C) automatic sidecar injection? +aegis 
x 2022-12-24 replace aegis-workload-key with aegis-workload-id everywhere for consistency pri:A +aegis @‚ñ∂Ô∏è
(E) we need an unregister flow for the deleted workloads too. -- or do we? not sure +aegis -- since the workload can revive, it might still be entitled to the same secrets.
(A) create a mini powerpoint (like a pitch deck) +aegis 
(B) age as an encryption tool https://github.com/FiloSottile/age +aegis @home 
(C) enable automatic (and manual) rotation of tokens and secrets +aegis 
(A) sealed secrets model with a twist: Sealed Secrets controller on the cluster, and the public key is available to the developers. This way, only the cluster can decrypt the secrets, and the developers can only encrypt them. -- so if the Notary has a persistent private key and it dispatches public key to Safe; then Safe can encrypt the admin token; it can send the encrypted admin token to Notary for validation. -- whatever the cluster operator enters as the token will be encrypted and sent to notary too. -- this way, safe can remain stateless, it does not have to know the admin token to restore its state; it only has to store an encrypted version of admin token on a persistent storage. ---- that solves the first part of the problem. -- the second part is restoring secrets when safe gets evicted -- the third part is rotation of the private keys and restoring the private key when notary gets evicted and --- but then we end up keeping the private key in the cluster -- even if we have a replicated setup if the private key is lost, access to the entire data is gone. -- so better to deliver a private key to administrator too; so if notary crashes the admin will have to provide the private key, and if vault crashes, everything is fine. -- then admin can manage the rotation of keys too by providing the private key that they have. -- private key  is NEVER stored on cluster disk, it will always be in memory. --- only encytped data will be stored on disk -- and this way we can also encrypt the kv pairs on disk using the public key too.